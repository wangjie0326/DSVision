# DSVision 答辩测试数据集

## 📊 所有测试数据一览表

你可以直接复制这些数据粘贴到系统中进行演示。

---

## 🔷 线性结构测试数据

### 1. 顺序表（Sequential List）

#### 测试1：基础操作演示
```
初始化数据：1,2,3,4,5
操作顺序：
1. Batch Init → "1,2,3,4,5"
2. Insert → Value: "99", Index: "2"
3. Delete → Index: "1"
4. Search → Value: "4"
```

**预期结果**：
- 初始：[1, 2, 3, 4, 5]
- 插入后：[1, 2, 99, 3, 4, 5]
- 删除后：[2, 99, 3, 4, 5]
- 搜索结果：找到4在位置2

**演示时间**：30秒

---

#### 测试2：大数据操作（可选）
```
初始化数据：1,10,20,30,40,50,60,70,80,90
操作顺序：
1. Batch Init → "1,10,20,30,40,50,60,70,80,90"
2. Insert → Value: "55", Index: "5"
3. Delete → Index: "0"
4. Search → Value: "70"
```

**演示时间**：30秒

---

### 2. 链表（Linked List）

#### 测试1：基础链表操作
```
初始化数据：10,20,30,40,50
操作顺序：
1. Batch Init → "10,20,30,40,50"
2. Insert → Value: "0", Index: "0"     （头部插入）
3. Insert → Value: "60", Index: "6"    （尾部插入）
4. Delete → Index: "2"
5. Search → Value: "20"
```

**预期结果**：
```
初始：0 → 10 → 20 → 30 → 40 → 50
删除后：0 → 10 → 30 → 40 → 50 → 60
搜索20：未找到（已删除）
```

**演示时间**：30秒

---

#### 测试2：链表综合操作
```
初始化数据：1,2,3
操作顺序：
1. Batch Init → "1,2,3"
2. Insert (头部) → Value: "0"
3. Insert (中间) → Value: "15", Index: "2"
4. Insert (尾部) → Value: "4"
5. Search → Value: "15"
```

**演示时间**：30秒

---

### 3. 栈（Stack）

#### 测试1：标准栈操作
```
操作顺序：
1. Push → "1"
2. Push → "2"
3. Push → "3"
4. Push → "4"
5. Peek
6. Pop
7. Pop
8. Peek
```

**预期结果**：
```
入栈后：[1, 2, 3, 4]（4在顶）
Peek：4
Pop两次：[1, 2]（2在顶）
```

**演示时间**：20秒

---

#### 测试2：栈溢出演示（可选）
```
操作顺序：
1. 快速入栈10个元素：1到10
2. Peek检查栈顶
3. 快速出栈5个元素
4. 再Peek
```

**演示时间**：20秒

---

## 🌳 树形结构测试数据

### 4. 二叉搜索树（BST）

#### 测试1：经典BST构建（推荐）
```
使用数据：50, 30, 70, 20, 40, 60, 80

【方式A：手动操作】
操作顺序：
1. Insert → "50"
2. Insert → "30"
3. Insert → "70"
4. Insert → "20"
5. Insert → "40"
6. Insert → "60"
7. Insert → "80"
8. Search → "40"
9. Min / Max

【方式B：使用DSL】
BST myBST {
    insert 50
    insert 30
    insert 70
    insert 20
    insert 40
    insert 60
    insert 80
}
```

**预期结果**：
```
        50
       /  \
      30   70
     / \   / \
   20  40 60 80
```

**树的信息**：
- 节点数：7
- 高度：3
- 最小值：20
- 最大值：80
- 搜索40的路径：50 → 30 → 40

**演示时间**：1分钟

---

#### 测试2：更复杂的BST
```
使用数据：50, 25, 75, 10, 30, 60, 80, 5, 15, 27, 35, 55, 65, 78, 90

【使用DSL】
BST complexBST {
    insert 50
    insert 25
    insert 75
    insert 10
    insert 30
    insert 60
    insert 80
    insert 5
    insert 15
    insert 27
    insert 35
}
```

**树的信息**：
- 节点数：11
- 高度：4

**演示时间**：1分钟

---

#### 测试3：删除操作演示
```
先构建上面的树，然后：
1. Delete → "20"    （叶子节点）
2. Delete → "30"    （有一个子节点）
3. Delete → "50"    （有两个子节点）
```

**说明**：
- 删除叶子节点：直接移除
- 删除单子节点：用子节点替换
- 删除双子节点：用右子树最小值替换

**演示时间**：30秒

---

### 5. 哈夫曼树 - 文本模式

#### 测试1：简短文本
```
输入文本："HELLO"

字符频率：
H - 1次
E - 1次
L - 2次
O - 1次

【使用DSL】
Huffman textHuffman {
    build_text "HELLO"
    show_codes
}
```

**预期编码**：
```
L: 1       （频率最高，编码最短）
H: 00
E: 01
O: 10
```

**演示时间**：30秒

---

#### 测试2：常见单词
```
输入文本："MISSISSIPPI"

字符频率：
M - 1, I - 4, S - 4, P - 2

【使用DSL】
Huffman huffman2 {
    build_text "MISSISSIPPI"
    show_codes
    encode "MISSISSIPPI"
}
```

**演示时间**：30秒

---

#### 测试3：编码演示
```
先构建Huffman树，然后：

Encode → "HI"
结果：需要计算

Decode → "1001"  （根据生成的编码表反解）
```

**演示时间**：20秒

---

### 6. 哈夫曼树 - 数字模式（创新点 - 必演）

#### 测试1：基础数字模式
```
输入数据：[2, 4, 6, 8]

【使用DSL】
Huffman numberHuffman {
    build_numbers [2, 4, 6, 8]
}

【使用UI】
Mode: "Number Mode"
Numbers: "2,4,6,8"
```

**演示重点**：
观察顶部频率面板的实时更新：
- 初始：[2, 4, 6, 8]（2和4红色高亮）
- 第1步合并：[6, 6, 8]（6和6红色高亮）
- 第2步合并：[8, 12]（8和12红色高亮）
- 第3步合并：[20]（完成）

**演示时间**：45秒

---

#### 测试2：中等复杂度
```
输入数据：[1, 2, 3, 4, 5, 6]

【使用DSL】
Huffman huffman3 {
    build_numbers [1, 2, 3, 4, 5, 6]
}
```

**演示重点**：
- 更多的合并步骤
- 频率面板的多次更新
- 最终树的复杂结构

**演示时间**：1分钟

---

#### 测试3：不均匀分布
```
输入数据：[1, 1, 1, 1, 10]

说明：有一个频率非常高的值

【使用DSL】
Huffman huffman4 {
    build_numbers [1, 1, 1, 1, 10]
}
```

**演示重点**：
- 高频元素的编码会很短
- 低频元素的编码会很长
- 展示哈夫曼算法的优化性质

**演示时间**：45秒

---

## 🎭 扩展功能测试数据

### 7. AVL树（自平衡）

#### 测试1：导致旋转的插入序列
```
【LL情况】
插入：30 → 20 → 10
系统会进行左旋（LL rotation）

【使用DSL】
AVL avlLL {
    insert 30
    insert 20
    insert 10
}
```

**预期结果**：
```
插入10后失衡 → 右旋 → 平衡
    20
   /  \
  10  30
```

---

#### 测试2：RR情况（右旋）
```
【RR情况】
插入：10 → 20 → 30

【使用DSL】
AVL avlRR {
    insert 10
    insert 20
    insert 30
}
```

**预期结果**：左旋后平衡
```
    20
   /  \
  10  30
```

---

#### 测试3：完整AVL演示
```
【连续插入演示】
插入序列：50 → 25 → 75 → 10 → 30 → 60 → 80

【使用DSL】
AVL myAVL {
    insert 50
    insert 25
    insert 75
    insert 10
    insert 30
    insert 60
    insert 80
}
```

**演示重点**：观察树在插入过程中的自动平衡

**演示时间**：1分钟

---

### 8. DSL语言演示

#### 测试1：简单DSL
```
Sequential simpleList {
    init [1, 2, 3, 4, 5]
    insert 99 at 2
    delete at 1
    search 3
}
```

**时间**：20秒

---

#### 测试2：中等复杂DSL
```
Linked linkedList {
    init [10, 20, 30, 40, 50]
    insert_head 0
    insert_tail 60
    delete at 2
    search 30
}
```

**时间**：20秒

---

#### 测试3：树结构DSL
```
BST treeDSL {
    insert 50
    insert 30
    insert 70
    insert 20
    insert 40
    insert 60
    insert 80
    search 40
    min
    max
}
```

**时间**：30秒

---

#### 测试4：Huffman DSL
```
Huffman huffmanDSL {
    build_text "ABRACADABRA"
    show_codes
}

# 或数字模式
Huffman huffmanNum {
    build_numbers [5, 9, 12, 13, 16, 45]
}
```

**时间**：45秒

---

### 9. LLM自然语言演示

#### 测试1：简单自然语言
```
用户输入："创建一个包含1、2、3、4、5的顺序表"

期望生成的DSL：
Sequential autoSeq {
    init [1, 2, 3, 4, 5]
}
```

**演示时间**：30秒

---

#### 测试2：复杂自然语言
```
用户输入："创建一个二叉搜索树，分别插入50、30、70、20、40、60、80"

期望生成的DSL：
BST autoTree {
    insert 50
    insert 30
    insert 70
    insert 20
    insert 40
    insert 60
    insert 80
}
```

**演示时间**：30秒

---

#### 测试3：Huffman自然语言
```
用户输入："用数字2、4、6、8构建哈夫曼树"

期望生成的DSL：
Huffman autoHuffman {
    build_numbers [2, 4, 6, 8]
}
```

**演示时间**：30秒

---

## 💾 数据保存和恢复演示

### 测试步骤：
```
1. 创建一个树结构（比如BST）
2. 构建数据
3. 点击"Save"按钮
   → 系统下载：bst_<timestamp>.json
4. 打开另一个数据结构
5. 点击"Import"
   → 选择之前下载的JSON文件
   → 系统恢复之前的BST
6. 继续编辑（比如再插入元素）
```

**演示时间**：30秒

---

## 📋 完整答辩时间表（10分钟版）

```
开场（30秒）
    ↓
顺序表演示（30秒）  ← 数据：[1,2,3,4,5]
    ↓
链表演示（30秒）    ← 数据：[10,20,30,40,50]
    ↓
栈演示（30秒）      ← Push 1,2,3,4 然后 Pop
    ↓
BST演示（1分钟）   ← 数据：50,30,70,20,40,60,80（或使用DSL）
    ↓
Huffman文本（30秒） ← 数据："HELLO"
    ↓
Huffman数字（45秒） ← 数据：[2,4,6,8]（创新点，必演）
    ↓
AVL树演示（45秒）   ← 数据：10,20,30
    ↓
DSL演示（30秒）     ← 使用上面的BST DSL
    ↓
LLM演示（30秒）    ← 自然语言 → DSL
    ↓
总结（30秒）
```

**总时间**：约9-10分钟

---

## ✅ 演示数据清单

- [ ] 顺序表数据：1,2,3,4,5
- [ ] 链表数据：10,20,30,40,50
- [ ] 栈操作：1,2,3,4（入栈）
- [ ] BST数据：50,30,70,20,40,60,80
- [ ] Huffman文本：HELLO
- [ ] Huffman数字：2,4,6,8
- [ ] AVL数据：10,20,30
- [ ] DSL脚本（已复制）
- [ ] LLM提示词（已准备）

---

## 💡 演示技巧

1. **动作要慢**
   - 点击按钮后，等待动画完全播放再继续
   - 不要急着做下一个操作

2. **解释要清楚**
   - 指着屏幕上的元素说明
   - "你看这里..."、"注意这个..."

3. **准备后备方案**
   - 截图或录屏（防止现场卡顿）
   - 多个浏览器标签页（如果一个页面崩溃）

4. **体现创新点**
   - Huffman数字模式：频率面板实时更新
   - DSL：编写清晰的代码展示
   - LLM：展示自然语言转DSL的神奇

---

现在你有了所有需要的测试数据！直接复制使用就可以。祝答辩顺利！🎓
